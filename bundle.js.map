{"version":3,"file":"bundle.js","mappings":"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","sources":["webpack:///./src/GraphicsManager.ts","webpack:///./src/Tetromino.ts","webpack:///./src/main.ts","webpack:///./src/Board.ts","webpack:///./src/Game.ts","webpack:///./src/UserInput.ts"],"sourcesContent":["/**\n * Manages rendering on the canvas.\n *    - Canvas Sizing\n *    - Grid Management\n *    - Drawing Elements\n *    - Score Display\n */\n\nexport class GraphicsManager {\n  private canvas: HTMLCanvasElement;\n  private context: CanvasRenderingContext2D;\n  private board: any;\n  private cellSize: number;\n  private rows: number;\n  private cols: number;\n\n  constructor(canvas: HTMLCanvasElement, board: any) {\n    this.canvas = canvas;\n    this.context = canvas.getContext('2d')!;\n    this.context.imageSmoothingEnabled = true;\n    this.board = board;\n    \n    this.cellSize = 30;  // Initialize cellSize\n  \n    // Initialize rows and cols\n    this.rows = 0;\n    this.cols = 0;\n  \n    // set initial canvas size based on window dimensions\n    this.setCanvasSize();\n  \n    // recalculate rows and columns based on canvas size\n    this.updateGridSize();\n  }\n\n  // adjust canvas size\n  public setCanvasSize(): void {\n    // set the canvas width and height to maintain elongated rectangle\n    this.canvas.width = window.innerWidth * 0.4;\n    this.canvas.height = window.innerHeight * 0.8;\n  }\n\n  // calculate rows and columns that can fit\n  public updateGridSize(): void {\n    this.cellSize = 30;\n    this.rows = Math.floor(this.canvas.height / this.cellSize);\n    this.cols = Math.floor(this.canvas.width / this.cellSize);\n\n    // round down to nearest full cell\n    this.canvas.height = this.rows * this.cellSize;\n    this.canvas.width = this.cols * this.cellSize;\n  }\n\n  // clear canvas, prep for the next frame.\n  public clear(): void {\n    this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);\n  }\n\n  // iterate through grid, draw each cell with designated color or\n  // a transparent background if unoccupied.\n  public drawGrid(): void {\n    // Use this.board.grid to reference the grid\n    for (let y = 0; y < this.board.grid.length; y++) {\n      for (let x = 0; x < this.board.grid[y].length; x++) {\n        const color = this.board.grid[y][x];\n        if (color) {  // if not empty draw it\n          this.drawCell(x, y, color);\n        } else {  // else draw empty space\n          this.drawCell(x, y, 'transparent');\n        }\n      }\n    }\n  }\n\n  // draw only the current state of the board with placed blocks\n  private drawBoard(): void {\n    for (let y = 0; y < this.board.grid.length; y++) {\n      for (let x = 0; x < this.board.grid[y].length; x++) {\n        if (this.board.grid[y][x]) {\n          this.drawCell(x, y, this.board.grid[y][x]);\n        }\n      }\n    }\n  }\n\n  // render the current tetromino on the canvas\n  private drawTetromino(tetromino: any): void {\n    const shape = tetromino.getCurrentShape();\n    shape.forEach((row: any[], y: number) => {\n      row.forEach((value: number, x: number) => {\n        if (value) {\n          this.drawCell(tetromino.x + x, tetromino.y + y, tetromino.color);\n        }\n      });\n    });\n  }\n\n  // fill cell with color/border\n  private drawCell(x: number, y: number, color: string): void {\n    this.context.fillStyle = color;\n    this.context.fillRect(x * this.cellSize, y * this.cellSize, this.cellSize, this.cellSize);\n\n    this.context.strokeStyle = 'black';\n    this.context.strokeRect(x * this.cellSize, y * this.cellSize, this.cellSize, this.cellSize);\n  }\n\n  // display current score on the canvas.\n  private displayScore(score: number): void {\n    this.context.fillStyle = 'black';\n    this.context.font = '30px Arial';\n    this.context.fillText(`Score: ${score}`, 10, 30);\n  }\n\n  // central rendering function that clears the canvas, draws the grid, board, tetromino,\n  // and score in a single frame update.\n  public render(tetromino: any, score: number): void {\n    this.clear(); // clear for next frame\n    this.drawGrid(); // draw grid with dark lines\n    this.drawBoard(); // draw the current state\n    this.drawTetromino(tetromino); // draw current tetromino\n    this.displayScore(score);\n  }\n}","/**\n * Tetromino block definition and functionality.\n * Shape and color constant maps tetromino types to attributes.\n *    - shape: array of matrices where each matrix represents a rotation state,\n *      matrix uses 1s and 0s to define filled (1) and empty (0) blocks of the shape.\n *    - color\n *    - currentRotation: tracks rotation state in the shape array\n *    - current x and y offset on the game grid\n */\n\ninterface TetrominoShape {\n  shape: number[][][];\n  color: string;\n}\n\nconst TETROMINOS: { [key: string]: TetrominoShape } = {\n  I: {\n    shape: [\n      [[1, 1, 1, 1]],         // horizontal\n      [[1], [1], [1], [1]],   // vertical\n    ],\n    color: 'cyan',\n  },\n  J: {\n    shape: [\n      [[0, 0, 1], [1, 1, 1]],  // L-shape\n      [[1, 0, 0], [1, 1, 1]],  // rotated\n    ],\n    color: 'blue',\n  },\n  L: {\n    shape: [\n      [[1, 0, 0], [1, 1, 1]],  // L-shape\n      [[0, 0, 1], [1, 1, 1]],  // rotated\n    ],\n    color: 'orange',\n  },\n  O: {\n    shape: [\n      [[1, 1], [1, 1]],        // square\n    ],\n    color: 'yellow',\n  },\n  S: {\n    shape: [\n      [[0, 1, 1], [1, 1, 0]],  // Z-shape\n      [[1, 0], [1, 1], [0, 1]],// rotated\n    ],\n    color: 'green',\n  },\n  T: {\n    shape: [\n      [[0, 1, 0], [1, 1, 1]],  // T-shape\n      [[1, 0], [1, 1], [1, 0]],// rotated\n    ],\n    color: 'purple',\n  },\n  Z: {\n    shape: [\n      [[1, 1, 0], [0, 1, 1]],  // Z-shape\n      [[0, 1], [1, 1], [1, 0]],// rotated\n    ],\n    color: 'red',\n  },\n};\n\nexport class Tetromino {\n  shape: number[][][];\n  color: string;\n  currentRotation: number;\n  x: number;\n  y: number;\n\n  constructor(type: keyof typeof TETROMINOS) {\n    const tetrominoData = TETROMINOS[type];\n    this.shape = tetrominoData.shape;\n    this.color = tetrominoData.color;\n    this.currentRotation = 0;\n    this.x = 3; // starting position\n    this.y = 0;\n  }\n\n  // current rotation state + 1, cycling through \n  // the available shapes to simulate rotation\n  rotate(): void {\n    this.currentRotation = (this.currentRotation + 1) % this.shape.length;\n  }\n\n  // returns the current rotation shape matrix\n  getCurrentShape(): number[][] {\n    return this.shape[this.currentRotation];\n  }\n}","import { Game } from './Game';\nimport { Board } from './Board';\nimport { GraphicsManager } from './GraphicsManager';\nimport { UserInput } from './UserInput';\n\n\nconst canvas = document.getElementById('canvas') as HTMLCanvasElement;\nconst board = new Board(20, 10, canvas);\nconst game = new Game(canvas, board);\nconst userInput = new UserInput(game);\n\n// initialize GraphicsManager\nconst graphicsManager = new GraphicsManager(canvas, { grid: [] });\n\nfunction render(): void {\n  graphicsManager.clear(); // clear the canvas for the next frame\n  graphicsManager.drawGrid(); // draw the grid\n}\n\n// initial rendering\nrender();\n\nwindow.addEventListener('resize', () => {\n  graphicsManager.setCanvasSize();\n  graphicsManager.updateGridSize();\n  render(); // re-render grid after size update\n});","import { Tetromino } from \"./Tetromino\";\n\n/**\n * Represents the grid, manages the game board state, validates positions,\n * handles line clearing and draws on the board.\n *    - Grid Initialization\n *    - Position Validation\n *    - Tetromino Placement\n *    - Line Clearing\n *    - Tetromino Rendering \n *    - Cell Rendering\n */\n\nexport class Board {\n  private rows: number;\n  private cols: number;\n  private context: CanvasRenderingContext2D;\n  private cellSize: number;\n  public grid: (string | null)[][];\n\n  getCols(): number {\n    return this.cols;\n  }\n\n  getRows(): number {\n    return this.rows;\n  }\n\n  // initialize the board grid with rows, columns,\n  // 2D array where each cell is null.\n  constructor(rows: number, cols: number, canvas: HTMLCanvasElement) {\n    this.rows = rows;\n    this.cols = cols;\n    this.context = canvas.getContext('2d')!;\n    this.cellSize = 30; \n    this.grid = Array.from({ length: rows }, () => Array(cols).fill(null));\n  }\n\n  // check if current position and rotation fit within the board's \n  // bounds and if the space is unoccupied\n  isPositionValid(tetromino: Tetromino): boolean {\n    const shape = tetromino.getCurrentShape();\n    for (let y = 0; y < shape.length; y++) {\n      for (let x = 0; x < shape[y].length; x++) {\n        if (shape[y][x]) {\n          const gridX = tetromino.x + x;\n          const gridY = tetromino.y + y;\n\n          // check if the tetromino is within bounds and doesn't overlap\n          if (gridX < 0 || gridX >= this.cols || gridY >= this.rows || this.grid[gridY][gridX]) {\n            return false; // invalid position if outside bounds or collision\n          }\n        }\n      }\n    }\n    return true; // valid position\n  }\n\n  // place permanently on the grid, copy shape into the board,\n  // store the piece's color at the corresponding grid positions\n  placeTetromino(tetromino: Tetromino): void {\n    const shape = tetromino.getCurrentShape();\n    for (let row = 0; row < shape.length; row++) {\n      for (let col = 0; col < shape[row].length; col++) {\n        if (shape[row][col]) {\n          const gridX = tetromino.x + col;\n          const gridY = tetromino.y + row;\n\n          // check if coords are within bounds\n          if (gridY >= 0 && gridY < this.rows && gridX >= 0 && gridX < this.cols) {\n            this.grid[gridY][gridX] = tetromino.color; // store color in the grid\n          }\n        }\n      }\n    }\n  }\n\n  // scan for completely filled lines, remove from the grid and shifts\n  // everything above down by one line for each cleared line\n  clearFullLines(): number {\n    let linesCleared = 0;\n    for (let y = this.rows - 1; y >= 0; y--) {\n      if (this.grid[y].every(cell => cell !== null)) {\n        linesCleared++;\n        this.grid.splice(y, 1);\n        this.grid.unshift(Array(this.cols).fill(null)); // shift everything down\n      }\n    }\n    return linesCleared;\n  }\n\n  // draw moving tetromino on the board, fill the\n  // cells based on position\n  drawTetromino(tetromino: Tetromino): void {\n    const shape = tetromino.getCurrentShape();\n    const color = tetromino.color;\n    for (let y = 0; y < shape.length; y++) {\n      for (let x = 0; x < shape[y].length; x++) {\n        if (shape[y][x]) {\n          this.drawCell(tetromino.x + x, tetromino.y + y, color);\n        }\n      }\n    }\n  }\n\n  // helper, fill single cell with a specified\n  // color at given coordinates\n  drawCell(x: number, y: number, color: string): void {\n    this.context.fillStyle = color;\n    this.context.fillRect(x * this.cellSize, y * this.cellSize, this.cellSize, this.cellSize);\n  }\n}","import { GraphicsManager } from './GraphicsManager'\nimport { Tetromino } from './Tetromino'\nimport { Board } from './Board'\nimport { UserInput } from './UserInput';\n\n/**\n * Main controller.\n * Manages gameplay flow, rendering and interactions between \n * game components (board, tetrominoes, user input).\n *    - Initialization\n *    - Game Start and Loop\n *    - Tetromino Control\n *    - Collision Detection\n *    - Scoring and Game Over\n */\n\nexport class Game {\n  private canvas: HTMLCanvasElement;\n  private board: Board;\n  private graphicsManager: GraphicsManager;\n  private score: number;\n  private currentTetromino: Tetromino | null;\n  private isGameOver: boolean;\n\n  constructor(canvas: HTMLCanvasElement, board: Board) {\n    this.canvas = canvas;\n    this.board = board;\n    this.graphicsManager = new GraphicsManager(canvas, board);\n    this.score = 0;\n    this.currentTetromino = null;\n    this.isGameOver = false;\n\n    // start game\n    this.start();\n  }\n\n  // initiate game by spawning the first tetromino, enter gameLoop\n  start(): void {\n    this.spawnTetromino();\n    this.gameLoop();\n  }\n\n  // randomly select tetromino type, create new instance\n  spawnTetromino(): void {\n    const tetrominoTypes: string[] = ['I', 'J', 'L', 'O', 'S', 'T', 'Z'];\n    const randomType = tetrominoTypes[Math.floor(Math.random() * tetrominoTypes.length)];\n    this.currentTetromino = new Tetromino(randomType);\n  }\n\n  // run continuously moving the tetromino down,\n  // check for collisions with the board\n  gameLoop(): void {\n    if (this.isGameOver) return;\n\n    this.moveTetrominoDown();\n\n    // check for collision with the board\n    if (this.currentTetromino && !this.board.isPositionValid(this.currentTetromino)) {\n      // if the position is invalid, place tetromino and clear full lines\n      this.board.placeTetromino(this.currentTetromino);\n      const linesCleared = this.board.clearFullLines();\n      this.score += linesCleared * 1000; // add points for cleared lines\n      this.spawnTetromino(); // spawn a new tetromino\n\n      // check if the new tetromino is already colliding with the board (game over)\n      if (this.currentTetromino && !this.board.isPositionValid(this.currentTetromino)) {\n        this.isGameOver = true;\n        alert('GAME OVER');\n      }\n    }\n\n    // render updated game state\n    if (this.currentTetromino) {\n      this.graphicsManager.render(this.currentTetromino, this.score);\n    }\n\n    // continue the game loop\n    setTimeout(() => this.gameLoop(), 300); // adjust? 300ms per frame\n  }\n\n  // move tetromino down one row, checks for collisions\n  moveTetrominoDown(): void {\n    if (this.currentTetromino) {\n      this.currentTetromino.y++;\n\n      // check if the new position is valid\n      if (!this.board.isPositionValid(this.currentTetromino)) {\n        this.currentTetromino.y--;  // revert the tetromino to its previous position\n        this.board.placeTetromino(this.currentTetromino);  // place it on the board\n        const linesCleared = this.board.clearFullLines();  // clear full lines\n        this.score += linesCleared * 1000;  // add score for cleared lines\n        this.spawnTetromino();  // spawn new tetromino\n\n        // check if the new tetromino collides immediately after spawning\n        if (!this.board.isPositionValid(this.currentTetromino)) {\n          this.isGameOver = true;\n          alert('GAME OVER');\n        }\n      }\n    }\n  }\n\n  // allow horizontal and vertical movement based\n  moveTetromino(dx: number, dy: number): void {\n    if (this.currentTetromino) {\n      const newX = this.currentTetromino.x + dx;\n      const newY = this.currentTetromino.y + dy;\n\n      // check if the move is valid and update position\n      if (this.isValidMove(newX, newY, this.currentTetromino.getCurrentShape())) {\n        this.currentTetromino.x = newX;\n        this.currentTetromino.y = newY;\n      }\n    }\n  }\n\n  // rotate the current tetromino and verifies the rotation using `isValidMove`\n  // if the rotation is invalid, it reverts to the previous orientation.\n  rotateTetromino(): void {\n    if (this.currentTetromino) {\n      this.currentTetromino.rotate();\n\n      // check if the rotation is valid - if not, revert\n      if (!this.isValidMove(this.currentTetromino.x, this.currentTetromino.y, this.currentTetromino.getCurrentShape())) {\n        this.currentTetromino.rotate();\n      }\n    }\n  }\n\n  // check if a given position is within bounds and not colliding with\n  // existing blocks on the board. Returns `true` if the move is valid, otherwise `false`.\n  isValidMove(x: number, y: number, shape: number[][]): boolean {\n    const booleanShape: boolean[][] = shape.map(row => row.map(cell => cell !== 0));\n  \n    for (let row = 0; row < booleanShape.length; row++) {\n      for (let col = 0; col < booleanShape[row].length; col++) {\n        if (booleanShape[row][col]) {\n          const boardX = x + col;\n          const boardY = y + row;\n  \n          // check if the piece is out of bounds\n          if (boardX < 0 || boardX >= this.board.getCols() || boardY < 0 || boardY >= this.board.getRows()) {\n            return false;  // Out of bounds\n          }\n  \n          // check if the space is already occupied\n          if (this.board.grid[boardY] && this.board.grid[boardY][boardX]) {\n            return false;  // collision with another block\n          }\n        }\n      }\n    }\n    return true;\n  }  \n}","/**\n * Process user input through keyboard events,\n * communicate with game object.\n */\n\nexport class UserInput {\n  game: any; // reference to the game instance\n\n  constructor(game: any) {\n    this.game = game; // store a reference to the main game instance\n    this.bindEvents(); // listen and capture user input\n  }\n\n  bindEvents(): void {\n    window.addEventListener('keydown', (event: KeyboardEvent) => this.handleKeyDown(event));\n  }\n\n  handleKeyDown(event: KeyboardEvent): void {\n    const key = event.key;\n\n    switch (key) {\n      case 'ArrowLeft':  // left\n        this.game.moveTetromino(-1, 0);\n        break;\n      case 'ArrowRight': // right\n        this.game.moveTetromino(1, 0);\n        break;\n      case 'ArrowDown':  // down faster\n        this.game.moveTetromino(0, 1);\n        break;\n      case 'ArrowUp':    // rotate clockwise\n        this.game.rotateTetromino();\n        break;\n      default:\n        break; // ignore the rest for now\n    }\n  }\n}"],"names":["GraphicsManager","constructor","canvas","board","this","context","getContext","imageSmoothingEnabled","cellSize","rows","cols","setCanvasSize","updateGridSize","width","window","innerWidth","height","innerHeight","Math","floor","clear","clearRect","drawGrid","y","grid","length","x","color","drawCell","drawBoard","drawTetromino","tetromino","getCurrentShape","forEach","row","value","fillStyle","fillRect","strokeStyle","strokeRect","displayScore","score","font","fillText","render","TETROMINOS","I","shape","J","L","O","S","T","Z","Tetromino","type","tetrominoData","currentRotation","rotate","document","getElementById","getCols","getRows","Array","from","fill","isPositionValid","gridX","gridY","placeTetromino","col","clearFullLines","linesCleared","every","cell","splice","unshift","game","graphicsManager","currentTetromino","isGameOver","start","spawnTetromino","gameLoop","tetrominoTypes","randomType","random","moveTetrominoDown","alert","setTimeout","moveTetromino","dx","dy","newX","newY","isValidMove","rotateTetromino","booleanShape","map","boardX","boardY","bindEvents","addEventListener","event","handleKeyDown","key"],"sourceRoot":""}